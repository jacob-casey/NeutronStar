{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "49505afd",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "def ImportOrbitalCorrectionData(SOURCENAME):\n",
    "    orbdatafile = f'/home/jacob/Desktop/{SOURCENAME}/herx1.fits'\n",
    "    orbdataopen = astropy.io.fits.open(orbdatafile)\n",
    "    orbdata = orbdataopen[1].data\n",
    "    spindata = orbdataopen[2].data\n",
    "    orbdataopen.close()\n",
    "\n",
    "    RA = orbdata['RA']\n",
    "    DEC = orbdata['DEC']\n",
    "    BINARY = orbdata['BINARY']\n",
    "    PBINARY = orbdata['PBINARY']\n",
    "    PBDOT = orbdata['PBDOT']\n",
    "    BINARYEPOCH = orbdata['BINARYEPOCH']\n",
    "    AXSINI = orbdata['AXSINI']\n",
    "    ECCENTRICITY = orbdata['ECCENTRICITY']\n",
    "    EGRESS = orbdata['EGRESS']\n",
    "    INGRESS = orbdata['INGRESS']\n",
    "    OMEGA = orbdata['PERIAPSE']\n",
    "\n",
    "\n",
    "def ImportModulationFactor(SOURCENAME):\n",
    "    modulationfiles = sorted(glob(f'/home/jacob/Desktop/{SOURCENAME}/RFiles/ModulationFiles/ixpe_d*mfact_02.fits'))\n",
    "    for i,f in enumerate(modulationfiles):\n",
    "        detcode = int(f[f.find('ixpe_d')+6])\n",
    "        print(i,f,detcode)\n",
    "        with fits.open(modulationfiles[detcode-1]) as hdu:\n",
    "            if i == 0:\n",
    "                moddata = hdu[1].data\n",
    "                moddetector = np.full(len(hdu[1].data),detcode)\n",
    "                hdu.close()\n",
    "            else:\n",
    "                moddata = np.append(moddata,hdu[1].data)\n",
    "                moddetector = np.append(moddetector,np.full(len(hdu[1].data),detcode))\n",
    "                hdu.close()\n",
    "    moddata = np.array([moddata['ENERG_LO'],moddata['ENERG_HI'],moddata['SPECRESP'],moddetector]).T\n",
    "    moddata = pd.DataFrame(moddata,columns=['ENERG_LO', 'ENERG_HI','SPECRESP','detector'])\n",
    "\n",
    "\n",
    "def ImportDataFiles(OBSID):\n",
    "    BinaryCorrection = True\n",
    "    datafiles = sorted(glob(f'/home/jacob/Desktop/HerX-1/{OBSID}/event_l2/*barycorr*.fits*'))\n",
    "    for i,f in enumerate(datafiles):\n",
    "        detcode = int(f[f.find('det')+3])\n",
    "        print(i,f,detcode)\n",
    "        with fits.open(datafiles[detcode-1]) as hdu:\n",
    "            if (i ==0):\n",
    "                MJDREFI=hdu[0].header['MJDREFI']\n",
    "                MJDREFF=hdu[0].header['MJDREFF']\n",
    "                LIVETIME = hdu[0].header['LIVETIME']\n",
    "                events = hdu[1].data\n",
    "                detector = np.full(len(hdu[1].data),detcode)\n",
    "                hdu.close()\n",
    "            else:\n",
    "                events = np.append(events,hdu[1].data)\n",
    "                detector = np.concatenate((detector,np.full(len(hdu[1].data),i+1)))\n",
    "                hdu.close()\n",
    "def SetupBackGroundandEnergyBounds():\n",
    "    coords = pd.read_csv(f'/home/jacob/Desktop/{SOURCENAME}/CoordinatesofNS.txt',delim_whitespace=True)\n",
    "    CenterX, CenterY= coords['X'].loc[coords['OBS_ID'] == float(OBSID)].mean(),coords['Y'].loc[coords['OBS_ID'] == float(OBSID)].mean()\n",
    "    print(CenterX,CenterY)\n",
    "    radius = np.sqrt(((events['X']-CenterX)**2)+((events['Y']-CenterY)**2))\n",
    "\n",
    "    Bounds = (events['PI']>49) & (events['PI']<=200) & (radius<SOURCERAD)\n",
    "    Background = (events['PI']>49) & (events['PI']<=200) & (radius<4*SOURCERAD) & (radius>2*SOURCERAD)\n",
    "\n",
    "\n",
    "    evtback = events[Background]\n",
    "    events = events[Bounds]\n",
    "    print(len(events))\n",
    "    detback = detector[Background]\n",
    "    detector = detector[Bounds]\n",
    "\n",
    "def BinaryCorrection():\n",
    "    day=3600*24\n",
    "\n",
    "\n",
    "\n",
    "    TPIOVER2O=orbdata['BINARYEPOCH']-2400000.5\n",
    "    PORB=orbdata['PBINARY']*day\n",
    "    PORBDOT=orbdata['PBDOT']\n",
    "    ECCENTRICITY=orbdata['ECCENTRICITY']\n",
    "    OMEGA=orbdata['PERIAPSE']\n",
    "    ASINIOVERC=orbdata['AXSINI']\n",
    "    NUORB=1/PORB\n",
    "    NUORBDOT=-1/PORB/PORB*PORBDOT\n",
    "    met0=events['TIME'].min()##evtlist['TIME'].min()\n",
    "    MJDSTART=MJDREFF+MJDREFI+met0/day\n",
    "    print(MJDSTART)\n",
    "    NU=np.interp(MJDSTART,spindata['BARYTIME'],spindata['FREQUENCY'])\n",
    "    NUDOT=np.interp(MJDSTART,spindata['BARYTIME'],spindata['FDOT'])\n",
    "    TREFNU=MJDSTART\n",
    "    torb=((MJDREFF+MJDREFI)+events['TIME']/day-TPIOVER2O)*day##((MJDREFF+MJDREFI)+evtlist['TIME']/day-TPIOVER2O)*day\n",
    "    phaseorb=(0.25+torb*(NUORB+torb*NUORBDOT/2))                    \n",
    "    orbtime=ASINIOVERC*((np.sin(2*np.pi*phaseorb)-np.sin(np.pi/2))-\n",
    "                    0.5*ECCENTRICITY*(np.sin(4*np.pi*phaseorb-np.radians(OMEGA))-\n",
    "                                        np.sin(np.pi/2-np.radians(OMEGA))))\n",
    "    deltat=events['TIME']-orbtime-met0#evtlist['TIME']-orbtime-met0\n",
    "    freqtst=NU\n",
    "    if (NUDOT==0) & (MJDSTART < spindata['BARYTIME'].max()):\n",
    "        _ii=spindata['BARYTIME']>59000\n",
    "        nufunk=InterpolatedUnivariateSpline(spindata['BARYTIME'][_ii],spindata['FREQUENCY'][_ii],k=2)\n",
    "        nudd=nufunk.derivatives(MJDSTART)\n",
    "        NU=nudd[0]\n",
    "        NUDOT=nudd[1]/day\n",
    "        NUDDOT=nudd[2]/day/day\n",
    "    elif (NUDOT==0) & (MJDSTART > spindata['BARYTIME'].max()):\n",
    "        NU = spindata['FREQUENCY'][-1]\n",
    "        #NUDOT = spindata['FDOT'][-1]\n",
    "        NUDDOT = 0\n",
    "    else:\n",
    "        NUDDOT=0\n",
    "\n",
    "    #Adjust NU + (x) until the 2dhist looks aligned\n",
    "\n",
    "    adjustment = 0#1e-6#0#5e-5#1e-6#1e-7\n",
    "    phase=np.mod(deltat*((NU+adjustment)+0.5*deltat*(NUDOT*deltat*NUDDOT*0.3333333)),1)\n",
    "\n",
    "\n",
    "    df = np.array([events['TIME'],events['PI'],events['U'],events['Q'],events['W_MOM'],events['X'],events['Y']]).T\n",
    "    #df = df.byteswap().newbyteorder()\n",
    "\n",
    "    df = pd.DataFrame(df,columns=['Barycentered Times','CH','U','Q','W_mom','X','Y'])\n",
    "    df['Time'] = deltat\n",
    "    df['Phase'] = phase\n",
    "    df['detector'] = detector\n",
    "    df['OrbitalCorrectedTime'] = df['Time']\n",
    "\n",
    "    bindata=plt.hist2d(df['Phase'],df['Time'],bins=100)\n",
    "    plt.savefig(f'/home/jacob/Desktop/{SOURCENAME}/{OBSID}/plots/BeginningPeriodCorrection.pdf')\n",
    "    #for i in range(1,4):\n",
    "    #    print(i)\n",
    "    #    df.loc[df['detector']==i].to_csv(f'/home/jacob/Desktop/{OBSID}dataframeDetector{i}.csv',sep=',',header=True,mode='w',index=False,columns=['Barycentered Times','OrbitalCorrectedTime','Phase','X','Y'])\n",
    "\n",
    "\n",
    "def PeriodCorrection():\n",
    "    def FindPeriod(adjustment):\n",
    "        phase=np.mod(deltat*((NU+adjustment)+0.5*deltat*(NUDOT*deltat*NUDDOT*0.3333333)),1)\n",
    "        PulseP = np.histogram(phase,bins=100)\n",
    "        PF = (PulseP[0].max()-PulseP[0].min())/(PulseP[0].max()+PulseP[0].min())\n",
    "        return 1/PF\n",
    "    bnds = [(-1e-4,1e-4)]\n",
    "    initialguess=[0]\n",
    "    res = opt.minimize(FindPeriod,initialguess,method='nelder-mead',bounds = bnds)\n",
    "    NU += res.x\n",
    "    print(NU)\n",
    "    phase=np.mod(deltat*((NU)+0.5*deltat*(NUDOT*deltat*NUDDOT*0.3333333)),1)\n",
    "    df['Phase'] = phase\n",
    "    bindata=plt.hist2d(df['Phase'],df['Time'],bins=100)\n",
    "    plt.savefig(f'/home/jacob/Desktop/{SOURCENAME}/{OBSID}/plots/FinalPeriodCorrection.pdf')\n",
    "\n",
    "\n",
    "def PulseProfile():\n",
    "    PulseP = np.histogram(phase,bins=100)\n",
    "    print((PulseP[0].max()-PulseP[0].min())/(PulseP[0].max()+PulseP[0].min()))\n",
    "    Counts = PulseP[0]\n",
    "    P = []\n",
    "\n",
    "    CenterofBins = (PulseP[1][:-1] + PulseP[1][1:])/2\n",
    "    CenterofBins_ = np.append(CenterofBins,CenterofBins+1)\n",
    "    PulseP_ = np.append(PulseP[0],PulseP[0])\n",
    "\n",
    "    plt.figure()\n",
    "    plt.plot(CenterofBins_,PulseP_/LIVETIME)\n",
    "    plt.xlabel('Phase')\n",
    "    plt.ylabel('COUNTS/S')\n",
    "    plt.title(f'{OBSID} Pulse Profile')\n",
    "    #plt.ylim(0,0.06)\n",
    "    fig1 = plt.gcf()\n",
    "    plt.show\n",
    "    fig1.savefig(f'/home/jacob/Desktop/{SOURCENAME}/{OBSID}/plots/PulseProfile.pdf')\n",
    "\n",
    "def LightCurve():\n",
    "    binwidth = 500\n",
    "    lightcurve = plt.hist(df['Time'], bins = range(0,int(df['Time'].max()),binwidth) )\n",
    "    Counts = lightcurve[0]\n",
    "    CenterofLCurveBins = (lightcurve[1][:-1] + lightcurve[1][1:])/2\n",
    "\n",
    "    plt.figure()\n",
    "    plt.scatter(CenterofLCurveBins,Counts/binwidth,s=3)\n",
    "    plt.xlabel('Time [s]')\n",
    "    plt.ylabel('COUNTS/S')\n",
    "    plt.title(f'{OBSID} Light Curve')\n",
    "    plt.ylim(0.01,10)\n",
    "    plt.yscale('log')\n",
    "    fig1 = plt.gcf()\n",
    "    plt.show\n",
    "    fig1.savefig(f'/home/jacob/Desktop/{SOURCENAME}/{OBSID}/plots/LightCurve.pdf')\n",
    "\n",
    "    #NOTE for later, the lowered bits are caused by off times within the 250s bins, use the ontime columns to rectify\n",
    "\n",
    "def ImportARFMRF():\n",
    "    ARFfiles = sorted(glob(f'/home/jacob/Desktop/HerX-1/RFiles/*.arf'))\n",
    "\n",
    "    for i,f in enumerate(ARFfiles):\n",
    "        detcode = int(f[f.find('ixpe_d')+6])\n",
    "        print(i,f,detcode)\n",
    "        with fits.open(ARFfiles[detcode-1]) as hdu:\n",
    "            if (i ==0):\n",
    "                Response = hdu[1].data\n",
    "                detector = np.full(len(hdu[1].data),detcode)\n",
    "            else:\n",
    "                Response = np.append(Response,hdu[1].data)\n",
    "                detector = np.concatenate((detector,np.full(len(hdu[1].data),i+1)))\n",
    "\n",
    "    Response = np.array([Response['ENERG_LO'].flatten(),Response['ENERG_HI'].flatten(),Response['SPECRESP'].flatten()]).T\n",
    "    #Response = Response.byteswap().newbyteorder()\n",
    "    ARF = pd.DataFrame(Response,columns=['E_low','E_hi','Resp'])\n",
    "    ARF['detector'] = detector\n",
    "\n",
    "    RMFfiles = sorted(glob(f'/home/jacob/Desktop/{SOURCENAME}/RFiles/*.rmf'))\n",
    "\n",
    "    for i,f in enumerate(RMFfiles):\n",
    "        detcode = int(f[f.find('ixpe_d')+6])\n",
    "        print(i,f,detcode)\n",
    "        with fits.open(RMFfiles[detcode-1]) as hdu:\n",
    "            if (i ==0):\n",
    "                Response = hdu[2].data\n",
    "                detector = np.full(len(hdu[2].data),detcode)\n",
    "            else:\n",
    "                Response = np.append(Response,hdu[2].data)\n",
    "                detector = np.concatenate((detector,np.full(len(hdu[2].data),i+1)))\n",
    "    Response = np.array([Response['E_MIN'].flatten(),Response['E_MAX'].flatten(),Response['CHANNEL'].flatten()]).T\n",
    "    #Response = Response.byteswap().newbyteorder()\n",
    "    RMF = pd.DataFrame(Response,columns=['E_low','E_hi','CH'])\n",
    "    RMF['E_AVG'] = (RMF['E_low'] + RMF['E_hi'])/2\n",
    "    RMF['detector'] = detector\n",
    "\n",
    "def ChanneltoEnergyandWeights():\n",
    "    RMF = RMF.merge(moddata, left_on=['E_low','E_hi','detector'], right_on=['ENERG_LO','ENERG_HI','detector'], how='left' )\n",
    "    RMF = RMF.drop(columns=['ENERG_LO','ENERG_HI'])\n",
    "\n",
    "\n",
    "    df = df.merge(RMF,left_on=['CH','detector'],right_on=['CH','detector'],how='left')\n",
    "    df = df.drop(columns=['E_low','E_hi'])\n",
    "\n",
    "    df['U*W_mom'] = df['U']* df['W_mom']\n",
    "    df['Q*W_mom'] = df['Q']* df['W_mom']\n",
    "\n",
    "def ISpectra():\n",
    "    binwidth = 0.04 #The channel energy width is 0.04\n",
    "    ISpectra = np.histogram(df['E_AVG'], bins = np.arange(2,8,binwidth) )\n",
    "    Counts = ISpectra[0]\n",
    "    CenterofISpectraBins = (ISpectra[1][:-1] + ISpectra[1][1:])/2\n",
    "\n",
    "    plt.figure()\n",
    "    plt.scatter(CenterofISpectraBins,Counts/LIVETIME/binwidth,s=3)\n",
    "    plt.xlabel('Energy [KeV]')\n",
    "    plt.ylabel('COUNTS/S/KeV')\n",
    "    plt.title(f'{OBSID} I Spectra')\n",
    "    plt.ylim(0.01,10)\n",
    "    plt.yscale('log')\n",
    "    fig1 = plt.gcf()\n",
    "    plt.show()\n",
    "    fig1.savefig(f'/home/jacob/Desktop/{SOURCENAME}/{OBSID}/plots/CombinedISpectra.pdf')\n",
    "\n",
    "    binwidth = 0.04 #The channel energy width is 0.04\n",
    "    #ISpectra = plt.hist(df['E_AVG'], bins = np.arange(2,8,binwidth) )\n",
    "    plt.figure()\n",
    "    for det in range(1,3+1): #plus 1 so that we get all 3 detectors\n",
    "\n",
    "        ISpectra = np.histogram(df['E_AVG'].loc[df['detector'] == det], bins = np.arange(2,8,binwidth) )\n",
    "        Counts = ISpectra[0]\n",
    "        CenterofISpectraBins = (ISpectra[1][:-1] + ISpectra[1][1:])/2\n",
    "\n",
    "\n",
    "        plt.scatter(CenterofISpectraBins,Counts/LIVETIME/binwidth,s=3,label=f'Detector: {det}')\n",
    "    plt.xlabel('Energy [KeV]')\n",
    "    plt.ylabel('COUNTS/S/KeV')\n",
    "    plt.title(f'{OBSID} I Spectra')\n",
    "    #plt.ylim(0.01,10)\n",
    "    plt.yscale('log')\n",
    "    plt.legend()\n",
    "    fig1 = plt.gcf()\n",
    "    plt.show\n",
    "    fig1.savefig(f'/home/jacob/Desktop/{SOURCENAME}/{OBSID}/plots/ISpectra.pdf')\n",
    "\n",
    "    binwidth = 0.04 #The channel energy width is 0.04\n",
    "    #ISpectra = plt.hist(df['E_AVG'], bins = np.arange(2,8,binwidth) )\n",
    "    plt.figure()\n",
    "    for det in range(1,3+1): #plus 1 so that we get all 3 detectors\n",
    "\n",
    "        ISpectra = np.histogram(df['E_AVG'].loc[df['detector'] == det], bins = np.arange(2,8,binwidth) )\n",
    "        Counts = []\n",
    "        for i in np.arange(2,8-binwidth,binwidth):\n",
    "            C = df['W_mom'].loc[df['E_AVG'].between(i,i+binwidth)& (df['detector'] == det)].sum()\n",
    "            Counts = np.append(Counts,C)\n",
    "        CenterofISpectraBins = (ISpectra[1][:-1] + ISpectra[1][1:])/2\n",
    "\n",
    "\n",
    "        plt.scatter(CenterofISpectraBins,Counts/LIVETIME/binwidth,s=3,label=f'Detector: {det}')\n",
    "    plt.xlabel('Energy [KeV]')\n",
    "    plt.ylabel('COUNTS/S/KeV')\n",
    "    plt.title(f'{OBSID} Weighted I Spectra')\n",
    "    #plt.ylim(0.01,10)\n",
    "    plt.yscale('log')\n",
    "    plt.legend()\n",
    "    fig1 = plt.gcf()\n",
    "    plt.show()\n",
    "    fig1.savefig(f'/home/jacob/Desktop/{SOURCENAME}/{OBSID}/plots/WeightedISpectra.pdf')\n",
    "    plt.close()\n",
    "\n",
    "\n",
    "def WeightedQUspectra():\n",
    "    binwidth = 5/14 #The channel energy width is 0.04\n",
    "    #ISpectra = plt.hist(df['E_AVG'], bins = np.arange(2,8,binwidth) )\n",
    "    plt.figure()\n",
    "    for det in range(1,3+1): #plus 1 so that we get all 3 detectors\n",
    "\n",
    "        ISpectra = np.histogram(df['E_AVG'].loc[df['detector'] == det], bins = np.arange(2,8,binwidth)  )\n",
    "        CenterofISpectraBins = (ISpectra[1][:-1] + ISpectra[1][1:])/2\n",
    "        Q = []\n",
    "        Q_Wmom = []\n",
    "        W_mom = []\n",
    "        Qstd = []\n",
    "        I = []\n",
    "        binwidth_2 = binwidth/2\n",
    "        #for i in np.arange(2,8-binwidth,binwidth):\n",
    "        for i in CenterofISpectraBins:\n",
    "            I_ = len(df['Q'].loc[df['E_AVG'].between(i-binwidth_2,i+binwidth_2)& (df['detector'] == det)])\n",
    "            Q_ = df['Q'].loc[df['E_AVG'].between(i-binwidth,i+binwidth_2)& (df['detector'] == det)].sum()\n",
    "            Q_std = df['Q'].loc[df['E_AVG'].between(i-binwidth,i+binwidth_2)& (df['detector'] == det)].std()\n",
    "            Q_Wmom_ = df['Q*W_mom'].loc[df['E_AVG'].between(i-binwidth_2,i+binwidth_2)& (df['detector'] == det)].sum()\n",
    "            Wmom_ = df['W_mom'].loc[df['E_AVG'].between(i-binwidth_2,i+binwidth_2)& (df['detector'] == det)].mean()\n",
    "            Q = np.append(Q,Q_)\n",
    "            Q_Wmom = np.append(Q_Wmom, Q_Wmom_)\n",
    "            W_mom = np.append(W_mom,Wmom_)\n",
    "            Qstd = np.append(Qstd,Q_std)\n",
    "            I = np.append(I,I_)\n",
    "        Counts_Sec_KEV = (Q/LIVETIME/binwidth)\n",
    "        WeightedCounts_Sec_KEV = (Q_Wmom/LIVETIME/binwidth)\n",
    "        Q_Wmom_std = np.sqrt(abs(Qstd**2)*I)*W_mom/LIVETIME/binwidth\n",
    "\n",
    "        plt.errorbar(CenterofISpectraBins,WeightedCounts_Sec_KEV,yerr = Q_Wmom_std,xerr = binwidth/2,markersize=3,label=f'Detector: {det}',fmt='o')\n",
    "    plt.xlabel('Energy [KeV]')\n",
    "    plt.ylabel('Counts/S/KeV')\n",
    "    plt.title(f'{OBSID} Weighted Q Spectra')\n",
    "    plt.ylim(-0.004,0.004)\n",
    "    plt.hlines(0,2,8,color = 'grey')\n",
    "    plt.xlim(2,8)\n",
    "    #plt.yscale('log')\n",
    "    plt.legend()\n",
    "    fig1 = plt.gcf()\n",
    "    plt.show()\n",
    "    fig1.savefig(f'/home/jacob/Desktop/{SOURCENAME}/{OBSID}/plots/WeightedQSpectra.pdf')\n",
    "    plt.close()\n",
    "\n",
    "    #ISpectra = plt.hist(df['E_AVG'], bins = np.arange(2,8,binwidth) )\n",
    "    plt.figure()\n",
    "    for det in range(1,3+1): #plus 1 so that we get all 3 detectors\n",
    "\n",
    "        ISpectra = np.histogram(df['E_AVG'].loc[df['detector'] == det], bins = np.arange(2,8,binwidth)  )\n",
    "        CenterofISpectraBins = (ISpectra[1][:-1] + ISpectra[1][1:])/2\n",
    "        I = []\n",
    "        U = []\n",
    "        U_Wmom = []\n",
    "        W_mom = []\n",
    "        Ustd = []\n",
    "        for i in np.arange(2,8-binwidth,binwidth):\n",
    "            I_ = len(df['U'].loc[df['E_AVG'].between(i,i+binwidth)& (df['detector'] == det)])\n",
    "            U_ = df['U'].loc[df['E_AVG'].between(i,i+binwidth)& (df['detector'] == det)].sum()\n",
    "            U_std = df['U'].loc[df['E_AVG'].between(i,i+binwidth)& (df['detector'] == det)].std()\n",
    "            U_Wmom_ = df['U*W_mom'].loc[df['E_AVG'].between(i,i+binwidth)& (df['detector'] == det)].sum()\n",
    "            Wmom_ = df['W_mom'].loc[df['E_AVG'].between(i,i+binwidth)& (df['detector'] == det)].mean()\n",
    "            U = np.append(U,U_)\n",
    "            U_Wmom = np.append(U_Wmom, U_Wmom_)\n",
    "            W_mom = np.append(W_mom,Wmom_)\n",
    "            Ustd = np.append(Ustd,U_std)\n",
    "            I = np.append(I,I_)\n",
    "        Counts_Sec_KEV = (U/LIVETIME/binwidth)\n",
    "        WeightedCounts_Sec_KEV = (U_Wmom/LIVETIME/binwidth)\n",
    "        U_Wmom_std = np.sqrt(abs(Ustd**2)*I)*W_mom/LIVETIME/binwidth # I because that is the number of terms in our sum\n",
    "        plt.errorbar(CenterofISpectraBins,WeightedCounts_Sec_KEV,yerr = U_Wmom_std,xerr = binwidth/2,markersize=3,label=f'Detector: {det}',fmt='o')\n",
    "    plt.xlabel('Energy [KeV]')\n",
    "    plt.ylabel('Counts/S/KeV')\n",
    "    plt.title(f'{OBSID} Weighted U Spectra')\n",
    "    plt.ylim(-0.00,0.008)\n",
    "    #plt.yscale('log')\n",
    "    plt.legend()\n",
    "    plt.hlines(0,2,8,color = 'grey')\n",
    "    plt.xlim(2,8)\n",
    "    fig1 = plt.gcf()\n",
    "    plt.show()\n",
    "    fig1.savefig(f'/home/jacob/Desktop/{SOURCENAME}/{OBSID}/plots/WeightedUSpectra.pdf')\n",
    "    plt.close()\n",
    "\n",
    "def NormalizedQUPlot():\n",
    "    binwidth = 5/14 #The channel energy width is 0.04\n",
    "    #ISpectra = plt.hist(df['E_AVG'], bins = np.arange(2,8,binwidth) )\n",
    "    plt.figure()\n",
    "    for det in range(1,3+1): #plus 1 so that we get all 3 detectors    \n",
    "        I_Wmom = []\n",
    "        U_Wmom = []\n",
    "        Energy = []\n",
    "        Ustd = []\n",
    "        I = []\n",
    "        W_mom = []\n",
    "        for i in np.arange(2,8,binwidth):\n",
    "            CenterofISpectraBins_ = i +(binwidth/2) \n",
    "            I_ = df['W_mom'].loc[df['E_AVG'].between(i,i+binwidth)& (df['detector'] == det)].sum()\n",
    "            U_Wmom_ = df['U*W_mom'].loc[df['E_AVG'].between(i,i+binwidth)& (df['detector'] == det)].sum()\n",
    "            U_std = df['U'].loc[df['E_AVG'].between(i,i+binwidth)& (df['detector'] == det)].std()\n",
    "            Wmom_ = df['W_mom'].loc[df['E_AVG'].between(i,i+binwidth)& (df['detector'] == det)].mean()\n",
    "            U_Wmom = np.append(U_Wmom, U_Wmom_)\n",
    "            I_Wmom = np.append(I_Wmom, I_)\n",
    "            Energy = np.append(Energy,CenterofISpectraBins_)\n",
    "            Ustd = np.append(Ustd,U_std)\n",
    "            W_mom = np.append(W_mom,Wmom_)\n",
    "            I = np.append(I,len(df['U'].loc[df['E_AVG'].between(i,i+binwidth)& (df['detector'] == det)]))\n",
    "        U_Wmom_std = np.sqrt(abs(Ustd**2)*I)\n",
    "        U_Wmom_std = abs(np.sqrt(((abs(Ustd**2)*I*W_mom*W_mom)/(U_Wmom**2)) + ((I_Wmom**(1/4))/(I_Wmom**2)))*(U_Wmom/I_Wmom))\n",
    "\n",
    "\n",
    "        plt.errorbar(Energy,U_Wmom/I_Wmom,markersize=3,yerr = U_Wmom_std,xerr = binwidth/2,label=f'Detector: {det}',fmt='o')\n",
    "    plt.legend()\n",
    "    plt.title(f'{OBSID} Normalized, Weighted U')\n",
    "    plt.ylabel('U/I')\n",
    "    plt.xlabel('Energy [KeV]')\n",
    "    plt.hlines(0,2,8,color = 'grey')\n",
    "    plt.xlim(2,8)\n",
    "    fig1 = plt.gcf()\n",
    "    plt.show()\n",
    "    fig1.savefig(f'/home/jacob/Desktop/{SOURCENAME}/{OBSID}/plots/NormalizedWeightedU.pdf')\n",
    "    plt.close()\n",
    "\n",
    "    Ebinwidth = binwidth #The channel energy width is 0.04\n",
    "    #ISpectra = plt.hist(df['E_AVG'], bins = np.arange(2,8,binwidth) )\n",
    "    plt.figure()\n",
    "    for det in range(1,3+1): #plus 1 so that we get all 3 detectors    \n",
    "        I_Wmom = []\n",
    "        Q_Wmom = []\n",
    "        Energy = []\n",
    "        Qstd = []\n",
    "        I = []\n",
    "        W_mom = []\n",
    "        for i in np.arange(2,8,Ebinwidth):\n",
    "            CenterofISpectraBins_ = i +(Ebinwidth/2) \n",
    "            I_ = df['W_mom'].loc[df['E_AVG'].between(i,i+Ebinwidth)& (df['detector'] == det)].sum()\n",
    "            Q_Wmom_ = df['Q*W_mom'].loc[df['E_AVG'].between(i,i+Ebinwidth)& (df['detector'] == det)].sum()\n",
    "            Q_std = df['Q'].loc[df['E_AVG'].between(i,i+Ebinwidth)& (df['detector'] == det)].std()\n",
    "            Wmom_ = df['W_mom'].loc[df['E_AVG'].between(i,i+Ebinwidth)& (df['detector'] == det)].mean()\n",
    "            Q_Wmom = np.append(Q_Wmom, Q_Wmom_)\n",
    "            I_Wmom = np.append(I_Wmom, I_)\n",
    "            Energy = np.append(Energy,CenterofISpectraBins_)\n",
    "            Qstd = np.append(Qstd,Q_std)\n",
    "            W_mom = np.append(W_mom,Wmom_)\n",
    "            I = np.append(I,len(df['Q'].loc[df['E_AVG'].between(i,i+Ebinwidth)& (df['detector'] == det)]))\n",
    "        Q_Wmom_std = np.sqrt(abs(Qstd**2)*I)\n",
    "        Q_Wmom_std = abs(np.sqrt(((abs(Qstd**2)*I*W_mom*W_mom)/(Q_Wmom**2)) + ((I_Wmom**(1/4))/(I_Wmom**2)))*(Q_Wmom/I_Wmom))\n",
    "\n",
    "\n",
    "        plt.errorbar(Energy,Q_Wmom/I_Wmom,markersize=3,yerr = Q_Wmom_std,xerr = Ebinwidth/2,label=f'Detector: {det}',fmt='o')\n",
    "    plt.legend()\n",
    "    plt.title(f'{OBSID} Normalized, Weighted Q')\n",
    "    plt.hlines(0,2,8,color = 'grey')\n",
    "    plt.xlim(2,8)\n",
    "    plt.ylabel('Q/I')\n",
    "    plt.xlabel('Energy [KeV]')\n",
    "    fig1 = plt.gcf()\n",
    "    fig1.savefig(f'/home/jacob/Desktop/{SOURCENAME}/{OBSID}/plots/NormalizedWeightedQ.pdf')\n",
    "    plt.show()\n",
    "    #plt.savefig(f'/home/jacob/Desktop/HerX-1/{OBSID}/plots/NormalizedWeightedQ.pdf')\n",
    "    plt.close()\n",
    "\n",
    "\n",
    "def QUPLOTS():\n",
    "    PBinWidth = 1/15\n",
    "    PhaseBins = np.arange(0,1+PBinWidth,PBinWidth)\n",
    "    #print(PhaseBins)\n",
    "    U = []\n",
    "    Q = []\n",
    "    Ustd = []\n",
    "    Qstd = []\n",
    "    W_mom = []\n",
    "    for i in np.arange(0,len(PhaseBins)-1,1):\n",
    "        I = df['W_mom'].loc[df['Phase'].between(PhaseBins[i],PhaseBins[i+1])].sum()\n",
    "        Wmom_ = df['W_mom'].loc[df['Phase'].between(PhaseBins[i],PhaseBins[i+1])].mean()\n",
    "\n",
    "        U_ = df['U*W_mom'].loc[df['Phase'].between(PhaseBins[i],PhaseBins[i+1])].sum()\n",
    "        U = np.append(U,U_/I)\n",
    "        Ustd_ = df['U'].loc[df['Phase'].between(PhaseBins[i],PhaseBins[i+1])].std()\n",
    "        Ustd = np.append(Ustd, np.sqrt((((Ustd_/I)**2))*I))\n",
    "\n",
    "\n",
    "        Q_ = df['Q*W_mom'].loc[df['Phase'].between(PhaseBins[i],PhaseBins[i+1])].sum()\n",
    "        Q = np.append(Q,Q_/I)\n",
    "        Qstd_ = df['Q'].loc[df['Phase'].between(PhaseBins[i],PhaseBins[i+1])].std()\n",
    "\n",
    "        Qstd = np.append(Qstd, np.sqrt((((Qstd_/I)**2))*I))\n",
    "\n",
    "    fig,ax = plt.subplots(2,1,figsize=(5,7),gridspec_kw={'height_ratios':[3,1.5]})\n",
    "\n",
    "    #Draw circles at 10 and 20% polarization\n",
    "    circle = plt.Circle((0,0),0.1,fill = False,color = 'red',label ='10% Polarization')\n",
    "    ax[0].add_patch(circle) \n",
    "    circle = plt.Circle((0,0),0.2,fill = False,color = 'green',label ='20% Polarization')\n",
    "    ax[0].add_patch(circle)\n",
    "\n",
    "    t = np.sin(PhaseBins[0:-1])\n",
    "    ax[0].errorbar(Q,U,yerr = Ustd, xerr= Qstd,fmt='o',markersize = 0)\n",
    "    ax[0].scatter(Q,U,s = 20,zorder=2,c=t)\n",
    "    ax[0].set_ylim(-0.3,0.3)\n",
    "    ax[0].set_xlim(-0.3,0.3)\n",
    "    ax[0].hlines(0,-1,1,color = 'grey')\n",
    "    ax[0].vlines(0,-1,1,color='grey')\n",
    "\n",
    "    ax[0].set_xlabel('Q/I')\n",
    "    ax[0].set_ylabel('U/I')\n",
    "    ax[0].set_title(f'Phase Resolved U/I vs Q/I')\n",
    "    #plt.legend()\n",
    "    #plt.savefig(f'/home/jacob/Desktop/HerX-1/{OBSID}/plots/PhaseResolveQU.pdf')\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "    CenterofBins = (PulseP[1][:-1] + PulseP[1][1:])/2\n",
    "    PULSEP = np.array([CenterofBins,PulseP[0]]).T\n",
    "    PULSEP = pd.DataFrame(PULSEP, columns = ['Phase','Count'])\n",
    "    Count = np.empty(0)\n",
    "    CP = np.empty(0)\n",
    "    for i in range(len(PhaseBins)-1):\n",
    "        CP_ = (PhaseBins[i]+ PhaseBins[i+1])/2\n",
    "        CP = np.append(CP,CP_)\n",
    "        Count = np.append(Count,PULSEP['Count'].loc[PULSEP['Phase'].between(CP_-0.01,CP_+0.01)].mean())\n",
    "\n",
    "    #plt.figure()\n",
    "    ax[1].plot(CenterofBins,PulseP[0]/LIVETIME,color='red')\n",
    "\n",
    "    ax[1].scatter(CP,Count/LIVETIME, c = t,zorder=2)\n",
    "    ax[1].errorbar(CP,Count/LIVETIME,xerr = PBinWidth/2,color='blue',fmt='o',zorder=1)\n",
    "\n",
    "    ax[1].set_xlabel('Phase')\n",
    "    ax[1].tick_params(left = False,labelleft = False)\n",
    "    ax[1].set_ylabel('Arbitrary Units')\n",
    "    #ax[1].set_title(f'Pulse Profile')\n",
    "    #plt.ylim(0,0.06)\n",
    "\n",
    "    #ax[0].set_aspect('equal')\n",
    "    #ax[1].set_aspect('equal')\n",
    "    plt.tight_layout(pad = 1)\n",
    "    fig1 = plt.gcf()\n",
    "    plt.show\n",
    "    fig1.savefig(f'/home/jacob/Desktop/HerX-1/{OBSID}/plots/QUPlot_PulseP.pdf')\n",
    "    #plt.close()\n",
    "\n",
    "    EBinWidth = 5/14\n",
    "    U = []\n",
    "    Q = []\n",
    "    Ustd = []\n",
    "    Qstd = []\n",
    "    W_mom = []\n",
    "    for i in np.arange(2,8,EBinWidth):\n",
    "        I = df['W_mom'].loc[df['E_AVG'].between(i,i+EBinWidth)].sum()\n",
    "        Wmom_ = df['W_mom'].loc[df['E_AVG'].between(i,i+EBinWidth)].mean()\n",
    "\n",
    "        U_ = df['U*W_mom'].loc[df['E_AVG'].between(i,i+EBinWidth)].sum()\n",
    "        U = np.append(U,U_/I)\n",
    "        Ustd_ = df['U'].loc[df['E_AVG'].between(i,i+EBinWidth)].std()\n",
    "        Ustd = np.append(Ustd, np.sqrt((((Ustd_/I)**2))*I))\n",
    "\n",
    "\n",
    "        Q_ = df['Q*W_mom'].loc[df['E_AVG'].between(i,i+EBinWidth)].sum()\n",
    "        Q = np.append(Q,Q_/I)\n",
    "        Qstd_ = df['Q'].loc[df['E_AVG'].between(i,i+EBinWidth)].std()\n",
    "\n",
    "        Qstd = np.append(Qstd, np.sqrt((((Qstd_/I)**2))*I))\n",
    "\n",
    "    fig,ax = plt.subplots(2,1,figsize=(6,7))\n",
    "\n",
    "    #Draw circles at 10 and 20% polarization\n",
    "    circle = plt.Circle((0,0),0.1,fill = False,color = 'red',label ='10% Polarization')\n",
    "    ax[0].add_patch(circle) \n",
    "    circle = plt.Circle((0,0),0.2,fill = False,color = 'green',label ='20% Polarization')\n",
    "    ax[0].add_patch(circle)\n",
    "\n",
    "    t = np.arange(2,8,EBinWidth)\n",
    "    ax[0].errorbar(Q,U,yerr = Ustd, xerr= Qstd,fmt='o',markersize = 0)\n",
    "    ax[0].scatter(Q,U,s = 20,zorder=2,c=t)\n",
    "    ax[0].set_ylim(-0.3,0.3)\n",
    "    ax[0].set_xlim(-0.3,0.3)\n",
    "    ax[0].hlines(0,-1,1,color = 'grey')\n",
    "    ax[0].vlines(0,-1,1,color='grey')\n",
    "\n",
    "    ax[0].set_xlabel('Q/I')\n",
    "    ax[0].set_ylabel('U/I')\n",
    "    ax[0].set_title(f'Energy Resolved U/I vs Q/I')\n",
    "\n",
    "    mappable= ax[1].scatter(np.arange(2,8,EBinWidth),np.full(len(np.empty_like(np.arange(2,8,EBinWidth))),0),c=t)\n",
    "    #ax[1].set_xlabel('Energy [KeV]')\n",
    "    plt.tight_layout(pad=1)\n",
    "\n",
    "    children = fig1.get_children()[1]\n",
    "    #cset = ax[0].contourf(Q,U,t,)\n",
    "    fig.colorbar(mappable,ax=ax[0],label='Energy [KeV]')\n",
    "    ax[1].set_visible(False)\n",
    "    ax[0].set_aspect('equal',adjustable='box')\n",
    "    fig1 = plt.gcf()\n",
    "    plt.show()\n",
    "    #plt.legend()\n",
    "    fig1.savefig(f'/home/jacob/Desktop/HerX-1/{OBSID}/plots/EnergyResolveQU.pdf')\n",
    "    plt.close()\n",
    "\n",
    "\n",
    "def PhaseResolvedPolarization():\n",
    "    df['U*W_mom*ModF'] = df['U*W_mom'] / df['SPECRESP']\n",
    "    df['Q*W_mom*ModF'] = df['Q*W_mom'] / df['SPECRESP']\n",
    "\n",
    "    PA = []\n",
    "    PD = []\n",
    "    U_ = []\n",
    "    Q_ = []\n",
    "    Ustd = []\n",
    "    Qstd = []\n",
    "    Phase = []\n",
    "    PDE= np.empty(0)\n",
    "    PAE = np.empty(0)\n",
    "\n",
    "    for i in range(len(PhaseBins)-1):\n",
    "        I = df['W_mom'].loc[df['Phase'].between(PhaseBins[i],PhaseBins[i+1])].sum()\n",
    "        Wmom_ = df['W_mom'].loc[df['Phase'].between(PhaseBins[i],PhaseBins[i+1])].mean()\n",
    "\n",
    "\n",
    "        respstd = df['SPECRESP'].loc[df['Phase'].between(PhaseBins[i],PhaseBins[i+1])].std()\n",
    "        resp = df['SPECRESP'].loc[df['Phase'].between(PhaseBins[i],PhaseBins[i+1])].mean()\n",
    "\n",
    "\n",
    "        U = df['U*W_mom*ModF'].loc[df['Phase'].between(PhaseBins[i],PhaseBins[i+1])].sum()/I\n",
    "        Q = df['Q*W_mom*ModF'].loc[df['Phase'].between(PhaseBins[i],PhaseBins[i+1])].sum()/I\n",
    "\n",
    "        U_std = df['U'].loc[df['Phase'].between(PhaseBins[i],PhaseBins[i+1])].std()/I\n",
    "        Q_std = df['Q'].loc[df['Phase'].between(PhaseBins[i],PhaseBins[i+1])].std()/I\n",
    "\n",
    "        PDe = np.sqrt((((U*U_std)**2)+((Q*Q_std)**2))\n",
    "                                /((U**2)+((Q**2))))*100\n",
    "\n",
    "        PAe = np.sqrt(((Q*U_std)**2)+(((U*Q_std)**2))\n",
    "                               /(((U**2)+(Q**2))**2))*0.5*180/np.pi\n",
    "\n",
    "        PA = np.append(PA,np.degrees((0.5)*np.arctan2(U,Q)))\n",
    "        PD = np.append(PD,np.sqrt((U**2)+(Q**2))*100)\n",
    "        PDE = np.append(PDE,PDe*Wmom_)\n",
    "        PAE = np.append(PAE,PAe*Wmom_)\n",
    "        Phase = np.append(Phase,(PhaseBins[i]+PhaseBins[i+1])/2)\n",
    "        PDE = np.sqrt(abs(PD))\n",
    "        PAE = np.sqrt(abs(PA))\n",
    "        U_ = np.append(U_,U)\n",
    "        Q_ = np.append(Q_,Q)\n",
    "        Ustd = np.append(Ustd,np.sqrt(abs(U))*Wmom_*resp)\n",
    "        Qstd = np.append(Qstd,np.sqrt(abs(Q))*Wmom_*resp)\n",
    "\n",
    "    #Plot everything twice\n",
    "    Phase = np.append(Phase,Phase+1)\n",
    "    PA = np.append(PA,PA)\n",
    "    PD = np.append(PD,PD)\n",
    "    PDE = np.append(PDE,PDE)\n",
    "    PAE = np.append(PAE,PAE)\n",
    "    U_ = np.append(U_,U_)\n",
    "    Q_ = np.append(Q_,Q_)\n",
    "    Ustd = np.append(Ustd,Ustd)\n",
    "    Qstd = np.append(Qstd,Qstd)\n",
    "\n",
    "\n",
    "    fig,ax = plt.subplots(5,1,figsize=(5,25))\n",
    "\n",
    "    ax[0].plot(CenterofBins,PulseP[0]/LIVETIME,color='blue')\n",
    "    ax[0].plot(CenterofBins+1,PulseP[0]/LIVETIME,color='blue')\n",
    "\n",
    "    ax[2].errorbar(Phase,U_,xerr=PBinWidth/2,yerr = Ustd,fmt='o',markersize=5)\n",
    "    ax[2].set_title('U/I')\n",
    "    ax[2].set_ylim(-0.2,0.4)\n",
    "\n",
    "    ax[1].errorbar(Phase,Q_,xerr=PBinWidth/2,fmt='o',yerr=Qstd,markersize=5)\n",
    "    ax[1].set_title('Q/I')\n",
    "    ax[1].set_ylim(-0.3,0.3)\n",
    "\n",
    "    ax[3].errorbar(Phase,PD,xerr=PBinWidth/2,yerr=PDE,fmt='o',markersize=5)\n",
    "    ax[3].set_title('Polarization Degree')\n",
    "    ax[3].set_ylim(5,35)\n",
    "\n",
    "\n",
    "\n",
    "    ax[4].errorbar(Phase,PA,xerr=PBinWidth/2,yerr=PAE,fmt='o',markersize=5)\n",
    "    ax[4].set_title('Polarization Angle')\n",
    "    ax[4].set_ylim(20,80)\n",
    "\n",
    "    plt.tight_layout(pad=1)\n",
    "    fig1=plt.gcf()\n",
    "    plt.show()\n",
    "    fig1.savefig(f'/home/jacob/Desktop/HerX-1/{OBSID}/plots/Polarization&PulseProfile.pdf')\n",
    "\n",
    "def FullAnalysis(OBSID,SOURCENAME,SOURCERAD):\n",
    "    ImportOrbitalCorrectionData(SOURCENAME)\n",
    "    ImportModulationFactor(SOURCENAME)\n",
    "    ImportDataFiles(OBSID)\n",
    "    SetupBackGroundandEnergyBounds()\n",
    "    BinaryCorrection()\n",
    "    PeriodCorrection()\n",
    "    PulseProfile()\n",
    "    LightCurve()\n",
    "    ImportARFMRF()\n",
    "    ChanneltoEnergyandWeights()\n",
    "    ISpectra()\n",
    "    WeightedQUspectra()\n",
    "    NormalizedQUPlot()\n",
    "    PhaseResolvedPolarization()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cd466344",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
